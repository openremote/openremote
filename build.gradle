import java.nio.file.Paths

import static org.apache.tools.ant.taskdefs.condition.Os.FAMILY_WINDOWS
import static org.apache.tools.ant.taskdefs.condition.Os.isFamily

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

// Configure version based on Git tags
apply plugin: 'pl.allegro.tech.build.axion-release'
scmVersion {
    releaseOnlyOnReleaseBranches = true
    releaseBranchNames = ['main', 'master']
    unshallowRepoOnCI.set(true)
    versionCreator('simple')
    versionIncrementer('incrementMinor')
    repository {
        remote.set('origin')
    }
    tag {
        prefix.set('')
        // This deserializer prevents errors when tags exist that cannot be deserialized
        deserializer({config, position, tagName -> tagName ==~ /^[0-9]+\.[0-9]+\.[0-9]+$/ ? tagName : "1.1.0" })
        initialVersion({config, position -> '1.2.0'})
    }
}

allprojects {
    apply from: "${findProject(':openremote') != null ? project(':openremote').projectDir : rootDir}/project.gradle"
    version = scmVersion.version
}

// Uncomment the following to configure files to be encrypted/decrypted
// Each file must be explicitly added to .gitignore otherwise git commit will fail
// When using encryption the the GFE_PASSWORD environment variable must be set or the build will fail
// use ./gradlew encryptFiles to encrypt files
apply plugin: 'io.openremote.com.cherryperry.gradle-file-encrypt'
gradleFileEncrypt {
    // files to encrypt
    plainFiles.from('deployment/manager/fcm.json')
    // (optional) setup file mapping to store all encrypted files in one place for example
    //mapping = [ 'deployment/mySensitiveFile' : 'secrets/mySensitiveFile' ]
    // Use custom password provider as standard env mechanism doesn't seem to work
    passwordProvider = {
        def password = System.env.GFE_PASSWORD
        return password != null ? password.toCharArray() : ''.toCharArray()
    }
}

apply plugin: 'io.github.gradle-nexus.publish-plugin'
nexusPublishing {
    repositories {
        sonatype {
            nexusUrl = uri(findProperty('releasesRepoUrl'))
            snapshotRepositoryUrl = uri(findProperty('snapshotsRepoUrl'))
            username = findProperty('publishUsername')
            password = findProperty('publishPassword')
        }
    }
}
group = 'io.openremote'

tasks.register('checkFilesGitIgnoredNew', Exec) {
    // The provided checkFilesGitIgnored task doesn't work on Windows so here's one that does
    def args = []
    if (isFamily(FAMILY_WINDOWS)) {
        args.add('cmd')
        args.add('/c')
    }
    args.add('git')
    args.add('check-ignore')
    args.add('-q')
    args.addAll(project.getProperties().get('gradleFileEncrypt').plainFiles)

    commandLine args
}
// openremote .git dir doesn't exist when used as a submodule
def gitFile = Paths.get(projectDir.path, '.git').toFile()
checkFilesGitIgnoredNew.enabled = gitFile.exists() && gitFile.isDirectory()

tasks.register('clean') {
    doLast {
        delete 'tmp'
    }
}

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.ow2.asm:asm:9.5'
        classpath 'org.ow2.asm:asm-tree:9.5'
    }
}

subprojects {
    // Apply only if the project has a 'test' task
    tasks.withType(Test).configureEach { testTask ->
        outputs.upToDateWhen { false }
        useJUnitPlatform()

        testLogging {

            // set options for log level LIFECYCLE
            events = [
                TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED
            ]
            exceptionFormat = TestExceptionFormat.FULL
            showExceptions = true
            showCauses = true
            showStackTraces = true

            // set options for log level DEBUG and INFO
            debug {
                events = [
                    TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_OUT,
                    TestLogEvent.STANDARD_ERROR
                ]
                exceptionFormat = TestExceptionFormat.FULL
            }
            info.events = debug.events
            info.exceptionFormat = debug.exceptionFormat

            afterTest { desc, result ->
                logger.lifecycle "${desc.className} > ${desc.name} took: ${(result.endTime - result.startTime)}ms"
            }

            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                    def startItem = '|  ', endItem = '  |'
                    def repeatLength = startItem.length() + output.length() + endItem.length()
                    println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
                }
            }
        }
    }

    afterEvaluate { proj ->
        tasks.withType(Test).configureEach { testTask ->
            workingDir = findProject(":openremote") != null ? project("").projectDir : rootProject.projectDir
        }

        if (proj.plugins.hasPlugin('java')) {
            def entityAnnotation = 'Ljakarta/persistence/Entity;'

            proj.tasks.register('checkJpaEntitiesEquality') {
                group = 'verification'
                description = 'Ensure all JPA entities implement equals() and hashCode()'
                dependsOn proj.tasks.named('classes')

                doLast {
                    proj.sourceSets.main.output.classesDirs.each { dir ->
                        if (!dir.exists()) return

                        dir.eachFileRecurse { file ->
                            if (file.name.endsWith('.class')) {
                                def reader = new org.objectweb.asm.ClassReader(file.bytes)
                                def classNode = new org.objectweb.asm.tree.ClassNode()
                                reader.accept(classNode, 0)

                                def isEntity = classNode.visibleAnnotations?.any {
                                    it.desc == entityAnnotation
                                }

                                if (isEntity) {
                                    def methodNames = classNode.methods*.name
                                    def className = classNode.name.replace('/', '.')

                                    def missing = []
                                    if (!methodNames.contains('equals')) missing << 'equals()'
                                    if (!methodNames.contains('hashCode')) missing << 'hashCode()'

                                    if (!missing.isEmpty()) {
                                        println "âŒ Entity $className is missing: ${missing.join(', ')}"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Finalize the gradle test task with the npmTest task so that all tests can be run with gradle test.
// Runs backend tests first and then frontend tests. UI tests are registered under npmTest to avoid
// complications when configuring the test task on projects w/o the Java plugin where the test task is
// already defined. It also allows for easy exclusion using the `-x` argument (e.g. `gradle test -x npmTest`.)
tasks.register('test') {
    dependsOn subprojects.collect { it.tasks.matching { it.name == 'test' } }
}
tasks.register('npmTest') {
    dependsOn subprojects.collect { it.tasks.matching { it.name == 'npmTest' } }
}
tasks.named('test') {
    finalizedBy tasks.named('npmTest')
}

tasks.register('startInfra', Exec) {
    group = 'application'
    description = 'Starts the development infrastructure (PostgreSQL, Keycloak)'
    commandLine 'docker', 'compose', '-f', 'profile/dev-testing.yml', 'up', '-d', '--wait'
}

tasks.register('stopInfra', Exec) {
    group = 'application'
    description = 'Stops the development infrastructure'
    commandLine 'docker', 'compose', '-f', 'profile/dev-testing.yml', 'down'
}

tasks.register('runManager') {
    group = 'application'
    description = 'Runs the Manager application (requires startInfra)'
    dependsOn ':manager:run'
}

tasks.register('buildUI') {
    group = 'application'
    description = 'Builds the UI'
    dependsOn ':ui:app:manager:npmBuild'
}


ext.runEnvDefaults = [
 OR_DB_HOST      : "host.docker.internal",
 OR_KEYCLOAK_HOST: "host.docker.internal",
]

// Resolve order: -PKEY=value  -> OS env KEY  -> default
def resolvedEnvValue(String key, String defaultValue = null) {
 providers.gradleProperty(key)
   .orElse(providers.environmentVariable(key))
   .orElse(defaultValue != null ? providers.provider { defaultValue } : providers.provider { "" })
   .get()
}

// Apply a whole env map at once (so adding/removing env is just editing maps)
def applyRunEnv(JavaExec t, Map<String, String> extra = [:]) {
 def keys = (runEnvDefaults.keySet() + extra.keySet()).toSet()
 def envMap = [:]
 keys.each { k ->
   envMap[k] = resolvedEnvValue(k as String, extra[k] ?: runEnvDefaults[k])
 }
 t.environment(envMap)
}

tasks.register('runDemo', JavaExec) {
 group = 'application'
 description = 'Runs the Manager with Demo Setup'
 dependsOn ':manager:classes'
 classpath = files({ project(':manager').sourceSets.main.runtimeClasspath })
 mainClass = 'org.openremote.manager.Main'

 standardOutput = System.out
 errorOutput = System.err

 applyRunEnv(delegate as JavaExec, [
     OR_SETUP_TYPE: "demo",
 ])
}

tasks.register('runTest', JavaExec) {
 group = 'application'
 description = 'Runs the Manager with Test Setup'
 dependsOn ':manager:classes'
 classpath = files({ project(':manager').sourceSets.main.runtimeClasspath })
 mainClass = 'org.openremote.manager.Main'

 applyRunEnv(delegate as JavaExec)
}
