<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd = "http://www.w3.org/2001/XMLSchema"
            xmlns = "http://www.openremote.org" targetNamespace = "http://www.openremote.org">

  <xsd:annotation>
    <xsd:documentation><![CDATA[

      OpenRemote Controller XML Schema, version 2.0.
      Authors: Juha Lindfors, Dan Cong, Javen Zhang.

      This defines the following:

      1. device component: such as a switch or a slider... whose id is consistent with
                           the one in panel.xml
      2. status sensor :   used to do polling to get current status of a device
      3. device command:   such as "TV on", to support different device command protocol
      4. configuration:    controller configuration properties

    ]]></xsd:documentation>
  </xsd:annotation>

  <!--
   =================================================================================================

     Top-level <openremote> tag

   =================================================================================================
   -->
  <xsd:element name = "openremote">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

        The top level (typically root) element.

        The document is structured into four main sections: components, sensors, commands and
        configuration.

        Components aggregate sets of commands and sensors into component level abstractions such
        as switches, sliders, labels, and so on. These are directly mapped via their ID to their
        corresponding panel UI widgets.

        Sensors abstract incoming events from devices, either through polling or listening to
        devices that actively broadcast their state changes. Sensors are bound to components
        that support displaying state changes via sensor's ID attribute. Sensors in this
        revision support four distinct datatypes: boolean switches (on/off), arbitrary range
        values (integers), a specific level range (integer between 0-100) and finite set of
        custom state strings.

        Commands abstract device read and write requests to protocol level wire format. Commands
        support set of properties that can be used to translate them to the desired protocol
        payload or serialization format. Protocol integration and adding new protocols happens
        via this abstraction.

        Configuration section are controller configuration properties that can be used to
        change the behavior of the controller itself either by editing the configuration locally
        or through online tools.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "components" />
        <xsd:element ref = "sensors" />
        <xsd:element ref = "commands" />
        <xsd:element ref = "config" />
      </xsd:sequence>
    </xsd:complexType>

    <xsd:unique name="uniqueIdsAccrossWholeDocument">
      <xsd:annotation>
        <xsd:documentation><![CDATA[
          Ensures that id field has unique value throught the whole document.
          All such fields should be of type idType.
        ]]></xsd:documentation>
      </xsd:annotation>

      <xsd:selector xpath=".//*"/>
      <xsd:field xpath="@id"/>
    </xsd:unique>
  </xsd:element>



  <!--
  =================================================================================================

    Section <components> tag

  =================================================================================================
  -->
  <xsd:element name = "components">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

        A component collection which includes components such as button, switch,
        gesture, label, etc.

        Each component is associated with an ID that is bound to a corresponding ID on the
        panel UI via panel.xml definition. This ID is also exposed through the controller's
        REST interface. Therefore, the panel definitions and implementations are independent
        of the protocol details and mappings on the controller and operate purely on the
        component ID (and to some extent, sensor ID) level of abstraction.

        Components aggregate protocol commands and sensors into a logical entity that can
        also be referenced through the controller's rule and scripting interfaces.

        This element itself aggregates further component elements, i.e.

        <openremote ...>
          <components>
            <[component]>
              ...
            <[component]/>

            <[component]>
              ...
            <[component]/>

            <[component]>
              ...
            <[component]/>
          </components>

          <sensors>
            ...
          </sensors>
          ...
        </openremote>

        Where [component] tags above are specific types of component elements, e.g. switch,
        image, slider, label, etc.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:group ref = "componentGroup" minOccurs = "0" maxOccurs = "unbounded"></xsd:group>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    Section <sensors> tag

  =================================================================================================
  -->
  <xsd:element name = "sensors">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

        Collection of sensors defined for the controller.

        Sensors operate on protocol handlers to execute read requests on devices to fetch the
        current device state, either through polling commands (for 'passive' devices) or through
        event listener implementations on devices that actively broadcast their state changes.

        A sensor can be bound to one or many components via its ID attribute. The currently held
        in-memory state of the sensor can also be retrieved through controller's REST/XML/JSON
        interface using the ID attribute.

        In the current controller revision, each polling sensor (passive devices) has an active
        thread associated with it in the Java runtime. This facilitates concurrent retrieval of
        device state. Sensors bound to event listeners do not create threads of their own but
        the event listener implementations themselves are usually multi-threaded.

        This element itself groups all sensors in the controller, i.e.

        <openremote ...>
          <components>
              ...
          </components>

          <sensors>
            <sensor id = "nnn" name = "Sensor's human readable name"
                  type = "[switch|range|level|custom]">

              <include type = "command" ref = "nnn"/>

              <[property]/>
              <[property]/>
            </sensor>

            <sensor ...>
              ...
            </sensor>
          </sensors>

          <commands>
            ...
          </commands>
          ...
        </openremote>

        Where in addition to an ID, each sensor has a (human-readable) name and a datatype.

        Sensors bind themselves to protocols via the command association through a child
        <include> element. Whether a sensor is actively polling a device or actively listening
        to device broadcasts depends on the protocol command implementation it is bound to.

        In addition, sensors may have specific list of property elements depending on its
        datatype. For example, range-type sensors have additional propery elements <min> and
        <max> that define the range boundaries. Custom-type sensors define a finite set of
        states they may return via explicit <state> property elements.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "sensor" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>


  <!--
  =================================================================================================

    Section <commands> tag

  =================================================================================================
  -->
  <xsd:element name = "commands">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

        Commands represent protocol handlers that are used to bind actions through panel user
        interfaces, scripts and rules to protocol-specific serialization or payload details.

        Commands are constructed as protocol-specific property lists where details of the
        properties and their values are left to protocol implementers to resolve. A command
        can represent either a read (poll) command or write command, an event listener, or some
        other suitable protocol structure.

        Commands are bound to either sensors (read commands and event listeners) or to components
        directly (write commands) through their ID referenced in the <include> of components
        and sensors.

        This element itself groups all protocol handlers in the controller, i.e.

        <openremote ...>
          ...
          <sensors>
            ...
          </sensors>

          <commands>
            <command id = "nnn" protocol = "protocol-id">
              <property name = "property-name" value = "property-value"/>
              <property name = "property-name" value = "property-value"/>
            </command>

            <command id = "nnn" protocol = "protocol-id">
              <property name = "property-name" value = "property-value"/>
              <property name = "property-name" value = "property-value"/>
            </command>

            <command id = "nnn" protocol = "protocol-id">
              <property name = "property-name" value = "property-value"/>
              <property name = "property-name" value = "property-value"/>
            </command>
          </commands>

          <config>
            ...
          </config>
        </openremote>

        Where a "protocol-id" attribute uniquely identifies a protocol implementation, and
        "property-name" and "property-value" attributes are name-value pairs that contain
        protocol implementation-specific details.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "command" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    Identifier (component, sensor, command) definition.

  =================================================================================================
  -->
  <xsd:simpleType name = "idType">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

        This is a unique natural number (upper bound 32-bit signed integer) identifier shared
        by all types within a controller.xml document instance, including component IDs,
        sensor IDs and command IDs.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:restriction base = "xsd:int">
      <xsd:minInclusive value = "1"/>
    </xsd:restriction>
  </xsd:simpleType>

  <!--
  =================================================================================================

    Component types (child element of <components>)

  =================================================================================================
  -->
  <xsd:group name = "componentGroup">
    <xsd:annotation>
      <xsd:documentation>
        <![CDATA[

          Specific component definitions. Components aggregate protocol handling commands and
          sensor into logical groups based on the type of the component. Component's ID is
          directly bound to panel UI widget IDs at a logical level (but not exposing protocol
          mapping details). Component definitions are also useful abstractions with the
          scripting and rules used within the controller.

          Current revision supports the following types of components:

          1. Switches   - two write commands to set device to on/off, sensor for reading (boolean)
                          on/off state from device
          2. Slider     - one write command to set device or property to a new (integer) value,
                          one sensor (range or level datatype) to read current device value
          3. Button     - one write command to send a new value to device

          4. Label      - one sensor to display a text representation of a bound
                          sensor value
          5. Image      - one sensor to display an image corresponding to a specified state value
                          returned by a sensor (switch-type sensor or custom sensor)
          6. ColorPicker - one write command to send a new value to device

        ]]>
      </xsd:documentation>
    </xsd:annotation>

    <xsd:choice>
      <xsd:element ref = "switch" />
      <xsd:element ref = "slider"/>
      <xsd:element ref = "button"/>
      <xsd:element ref = "label" />
      <xsd:element ref = "gesture" />
      <xsd:element ref = "image"/>
      <xsd:element ref = "colorpicker"/>
    </xsd:choice>
  </xsd:group>




  <!--
  =================================================================================================

    Switch Component (child element of <components>)

  =================================================================================================
  -->
  <xsd:element name = "switch">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Switch component is a two-state on/off switch with separate command sequences for
          both 'on' and 'off' functionality and a configurable sensor to reflect the device's
          current state.

          Both 'on' and 'off' command sequences may include multiple commands that are executed
          in response to a switch state change. A sensor bound to a switch component must also
          have 'switch' as its datatype.

          A switch component must have a controller unique integer identifier.

          An example of a switch component definition might look like this:

            <components>
              <switch id = "nnn">
                <on>
                  <include type = "command" ref = "nnn" />
                  <include type = "command" ref = "nnn" />
                  <include type = "command" ref = "nnn" />
                </on>

                <off>
                  <include type = "command" ref = "nnn" />
                </off>

                <include type = "sensor" ref = "nnn" />
              </switch>
              ...
            </components>


      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "on"  minOccurs = "1" maxOccurs = "1"/>
        <xsd:element ref = "off" minOccurs = "1" maxOccurs = "1" />
        <xsd:element ref = "include" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
    </xsd:complexType>
  </xsd:element>


  <!--   =====   SWITCH 'ON' OPERATION   =====   -->

  <xsd:element name = "on">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          The 'on' operation of a switch. The contents can be one or more <include> and <delay>
          elements that defines the sequence of write commands (and optional delays between
          commands) that should be executed in response to a switch 'on' state change request.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:group ref = "macroGroup" />
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>


  <!--   =====   SWITCH 'OFF' OPERATION   =====   -->

  <xsd:element name = "off">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          The 'off' operation of a switch. The contents can be one or more <include> and <delay>
          elements that defines the sequence of write commands (and optional delays between
          commands) that should be executed in response to a switch 'off' state change request.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:group ref = "macroGroup" />
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    Slider Component (child element of <components>)

  =================================================================================================
  -->
  <xsd:element name = "slider">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Slider component can be used to send a range of integer values to a device depending
          on slider state. Sliders can be 'active' in a sense that they can allow users to
          actively change their value (usually through an UI widget that allows a new value to
          be set), or passive ('read-only') in a sense that they only update and display current
          sensor state without allowing user to make updates.

          The 'setValue' operation is used to reference a write command which sets a new device
          value in response to a slider modification in the panel UI, or a script or rule in
          the controller. A sensor bound using 'include' element to a slider component is
          used to update the slider value in response to an event from a read command or event
          listener.

          A slider component must have a controller unique integer identifier.

          An example of a slider component definition might look like this:

            <components>
              <slider id = "nnn">
                <setValue>
                  <include type = "command" ref = "nnn" />
                </setValue>

                <include type = "sensor" ref = "nnn" />
              </slider>
              ...
            </components>


      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "setValue" minOccurs = "0" maxOccurs = "unbounded"/>
        <xsd:element ref = "include"  minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
    </xsd:complexType>
  </xsd:element>



  <!--   =====   SLIDER 'SETVALUE' OPERATION   =====   -->

  <xsd:element name = "setValue">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Specifies one or more write commands (using a nested <include> elements) that is used
          to update device(s) in response to a slider component update.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "include" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    Button Component (child element of <components>)

  =================================================================================================
  -->
  <xsd:element name = "button">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          A button component is a simple one-way component to send write commands to a device.
          One or more commands may be sent in sequence, and delays can be used where necessary
          between commands.

          A button component must have a controller unique integer identifier.

          An example button element is as follows:

            <components>
              <button id = "nnn">
                  <include type = "command" ref = "nnn" />
                  <include type = "command" ref = "nnn" />
                  <delay>500</delay>
                  <include type = "command" ref = "nnn" />
              </button>
              ...
            </components>

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:group ref = "macroGroup" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
    </xsd:complexType>
  </xsd:element>




  <!--
  =================================================================================================

    ColorPicker Component (child element of <components>)

  =================================================================================================
  -->
  <xsd:element name="colorpicker">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          A color picker component is a simple one-way component to send write commands to a device.
          One or more commands may be sent in sequence but no delays are allowed.

          A color picker component must have a controller unique integer identifier.

          An example color picker element is as follows:

            <components>
              <colorpicker id = "nnn">
                  <include type = "command" ref = "nnn" />
                  <include type = "command" ref = "nnn" />
              </colorpicker>
              ...
            </components>

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="include" minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:attribute name="id" type="idType" use="required" />
    </xsd:complexType>
  </xsd:element>




  <!--
  =================================================================================================

    Label Component (child element of <components>)

  =================================================================================================
  -->
  <xsd:element name = "label">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          A 'label' component is controller-side representation of an UI label widget that may
          be updated based on a sensor value.

          A label component may include a single 'sensor' type which is used as an input for
          a dynamic UI labels content.

          A label component must have a controller unique integer identifier.

          An example label element is as follows:

            <components>
              <label id = "nnn">
                  <include type = "sensor" ref = "nnn" />
              </label>
              ...
            </components>

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "include" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    Image Component (child element of <components>)

  =================================================================================================
  -->
  <xsd:element name = "image">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          An 'image' component is controller-side representation of a panel UI image that may
          be updated based on a sensor value.

          An image component may include a single 'sensor' type which is used as an input for
          a dynamic UI image content.

          An image component must have a controller unique integer identifier.

          An example image element is as follows:

            <components>
              <image id = "nnn">
                <include type = "sensor" ref = "nnn" />
              </image>
              ...
            </components>

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "include" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    Gesture (child element of <components>)

  =================================================================================================
  -->
  <xsd:element name = "gesture">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          A gesture component represents a command executed on the controller-side
          in response to a user gesture on the panel UI.

          A gesture component must have a controller unique integer identifier.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:group ref = "macroGroup" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
    </xsd:complexType>
  </xsd:element>




  <!--
  =================================================================================================

    Sensor definition (child element of <sensors>)

  =================================================================================================
  -->
  <xsd:element name = "sensor">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

      Sensor definition. Sensors abstract events of external device state, either through polling
      (explicit device read requests) or through event listeners (listening for active device state
      broadcasts).

      A sensor is bound to one or many components through its unique identifier. A sensor is
      associated with a datatype that indicates the types of values it can return.

      The current revision supports following datatypes for sensors: switch, level,
      range and custom state. Component types may place restrictions on what types of sensors
      they can be associated with.

      Sensors are associated with an active thread in the Java runtime. Sensors associated with
      read commands (polling) have a thread associated each. Sensors associated with event
      listeners do not create active threads on behalf of the controller but often create
      listening threads as part of the protocol implementation.

      Sensor state can be also retrieved directly through controller's REST API using the
      sensor's unique identifier as key. See
      http://www.openremote.org/display/docs/Controller+2.0+API+Documentation for additional
      detail.

      A typical sensor element in a controller.xml document looks like this:

      ...
      <sensors>
        <sensor id = "nnn" type = "[switch|level|range|custom]" name = "Doorbell">
          ...
        </sensor>
      </sensors>
      ...

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:group ref = "sensorGroup" minOccurs = "0" maxOccurs = "unbounded" />
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
      <xsd:attribute name = "type" type = "sensorType" use = "required" />
      <xsd:attribute name = "name" type = "xsd:string" use = "required" />
    </xsd:complexType>
  </xsd:element>



  <!--   =====  SENSOR PROPERTIES  =====   -->

  <xsd:group name="sensorGroup">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          A sensor may contain additional child elements that further defines its properties.
          Sensor properties may be optional or mandatory depending the sensor's type.

          In addition, a sensor has an <include> element which references the 'event producer'
          the sensor uses to collect its state values. An event producer is either a polling
          read command or an event listener. Both types of event producers use the sensor's
          unique identifier as a key to store device state to controller's in-memory state
          cache.

          The following sensor properties are used with specified sensor types:

          1. Switch sensor -- No mandatory additional sensor properties. May use <state> elements
                              to map "on" and "off" states to other values (for example to
                              "open" and "close" for a door sensor) which may in turn be bound to
                              a label component which is able to display customized values. This
                              state mapping mechanism may also be used to translate textual
                              descriptions of the switch state to localized languages.

          2. Range sensor  -- Mandatory <min> and <max> elements are used to define the boundary
                              values of the range sensor.

          3. Level sensor  -- No additional sensor properties. Has an implicit range of [0-100]
                              to which the device range values are scaled to.

          4. Custom sensor -- Maps specific state values from device to an alternative values
                              exposed to panels via a <state> elements

      ]]></xsd:documentation>
    </xsd:annotation>
    <xsd:choice>
      <xsd:element ref = "include" minOccurs = "0" maxOccurs = "unbounded" />
      <xsd:element ref = "state" minOccurs = "0" maxOccurs = "unbounded" />
      <xsd:element ref = "min" minOccurs = "0" maxOccurs = "1" />
      <xsd:element ref = "max" minOccurs = "0" maxOccurs = "1" />
    </xsd:choice>
  </xsd:group>


  <!-- Sensor <min> property -->

  <xsd:element name = "min">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          The <min> property defines the lower boundary of a range. Valid (and mandatory)
          for range-type sensors.

          An example of a range sensor definition:

          ...
          <sensors>
            <sensor id = "nnn" name = "Outdoor Temp" type = "range">
              <min value = "-50"/>
              <max value = "50"/>
              <include type = "command" ref = "mmm"/>
            </sensor>
          </sensors>
          ...

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:attribute name = "value" type = "xsd:int" use = "required" />
    </xsd:complexType>
  </xsd:element>


  <!-- Sensor <max> property -->

  <xsd:element name = "max">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          The <max> property defines the upper boundary of a range. Valid (and mandatory)
          for range-type sensors.

          An example of a range sensor definition:

          ...
          <sensors>
            <sensor id = "nnn" name = "Outdoor Temp" type = "range">
              <min value = "-50"/>
              <max value = "50"/>

              <include type = "command" ref = "mmm"/>
            </sensor>
          </sensors>
          ...

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:attribute name = "value" type = "xsd:int" use = "required" />
    </xsd:complexType>
  </xsd:element>


  <!-- Sensor <state> property -->

  <xsd:element name = "state">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          The <state> property defines a finite set of explicit state values that a custom-state
          sensor may return. If a value is also defined then the sensor's return values are mapped
          to the state names as well. This can be used for mapping explicit state values to more
          human-consumable values for the panel UI for example, or as a translation mechanism for
          localized interfaces.

          When both name and value attributes are defined in a <state> element, it can also be used
          with a switch-type sensor to translate the usual on/off values to other values.

          An example of a custom-type sensor is as follows:

          ...
          <sensors>
            <sensor id = "nnn" name = "Cloud Report" type = "custom">
              <state name = "Rain Clouds"/>
              <state name = "Cloudy"/>
              <state name = "Partly Cloudy"/>
              <state name = "Sunny"/>

              <include type = "command" ref = "mmm"/>
            </sensor>
          </sensors>
          ...

          Where in the above example, the sensor accepts four distinct values from the referenced
          event producer (read command or event listener).

          A mapping sensor could be used as follows:

          ...
          <sensors>
            <sensor id = "nnn" name = "Cloud Report" type = "custom">
              <state name = "Rain Clouds"   value = "1" />
              <state name = "Cloudy"        value = "2" />
              <state name = "Partly Cloudy" value = "3" />
              <state name = "Sunny"         value = "4" />

              <include type = "command" ref = "mmm"/>
            </sensor>
          </sensors>
          ...

          In the example above, the event producer returns values ranging from one to four which
          are then mapped to descriptive string values in the controller's in-memory device state
          cache. This sensor with descriptive string values can then be bound to a label
          component in the panel UI, for example, allowing it to display user-friendly description
          of the data returned by the event producers.

          Finally, the same mechanism can be used to translate events from event producers, in
          this case from a boolean switch sensor :

          ...
          <sensors>
            <sensor id = "nnn" name = "Localized Door Sensor" type = "switch">
              <state name = "Ouvert"   value = "on" />
              <state name = "Ferme"    value = "off" />

              <include type = "command" ref = "mmm"/>
            </sensor>
          </sensors>
          ...

          Note that the event processing chain in the controller's in-memory state cache can
          be used for similar effect and for more complex processing use-cases. Also bear in
          mind that UI rendering components bound to such sensor must support the known state
          strings or arbitrary state strings.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:attribute name = "name" use = "required" />
      <xsd:attribute name = "value" use = "optional" />
    </xsd:complexType>
  </xsd:element>



  <!--   =====  SENSOR DATATYPES  =====   -->

  <xsd:simpleType name = "sensorType">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Sensor data type definitions:

          1) Switch: returns boolean 'on' or 'off' strings
          2) Level:  An integer value as a string that is scaled to an implicit range of [0-100]
          3) Range:  Integer value as a string within a given boundary range
          5) Custom: A customized finite set of state strings

        ]]>
      </xsd:documentation>
    </xsd:annotation>

    <xsd:restriction base = "xsd:string">
      <xsd:enumeration value = "switch" />
      <xsd:enumeration value = "level" />
      <xsd:enumeration value = "range" />
      <xsd:enumeration value = "color" />
      <xsd:enumeration value = "custom" />
    </xsd:restriction>
  </xsd:simpleType>




  <!--
  =================================================================================================

    Protocol Handler (Command) definition (child element of <commands>)

  =================================================================================================
  -->
  <xsd:element name = "command">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Defines a protocol handler (command). Commands are created to handle protocol specific
          behavior when necessary to invoke either from sensors or components. Commands can
          represent device write requests, device state read requests or other protocol specific
          functionality, as necessary (for example, event listeners).

          A command has a mandatory per controller unique identifier that is used to bind it to
          sensors and components. A single command definition can be bound to multiple components
          and sensors.

          Command also has a protocol identifier which is used to map its implementation to an
          appropriate protocol in the controller. The valid values for 'protocol' attribute
          depend on the controller's configuration -- which protocols have been installed and
          what protocol identifiers they use.

          A generic form of a <command> element in a controller.xml document is therefore:

            <command id = "nnn" protocol = "protocol-id">
              <property ... />
              <property ... />
              ...
            </command>

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "property" minOccurs = "0" maxOccurs = "unbounded"/>
      </xsd:sequence>
      <xsd:attribute name = "id" type = "idType" use = "required" />
      <xsd:attribute name = "protocol" type = "xsd:string" use = "required"/>
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    INCLUDE ELEMENT

  =================================================================================================
  -->
  <xsd:element name="include">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Include element is used by components and sensors to reference to other components,
          sensors or protocol handlers (commands).

          The 'type' attribute indicates what type of component is being included or referenced.
          Currently valid values are either 'sensor' or 'command'.

          The 'ref' attribute must be the unique identifier of the referenced component or command.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:attribute name = "type" type = "xsd:string" />
      <xsd:attribute name = "ref" type = "idType" />
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    PROPERTY ELEMENT

  =================================================================================================
  -->
  <xsd:element name = "property">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Property element is used for setting protocol handler (command) properties, controller
          configuration properties, etc.

          Property element is a name-value pair where name attributes are strings and value
          attributes are string representations of datatypes (another string, integer as
          string, etc.)

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:attribute name = "name" type = "xsd:string" use = "required" />
      <xsd:attribute name = "value" type = "xsd:string" use = "required" />
    </xsd:complexType>
  </xsd:element>



  <!--
  =================================================================================================

    Macro group definition.

  =================================================================================================
  -->
  <xsd:group name = "macroGroup">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          A macro group defines a sequence of write commands (and optionally delays) that are
          executed in response to a component invocation for components that support macro
          inclusion.

      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:choice>
      <xsd:element ref = "delay" minOccurs = "0" maxOccurs = "unbounded"/>
      <xsd:element ref = "include"  minOccurs = "0" maxOccurs = "unbounded"/>
    </xsd:choice>
  </xsd:group>


  <!--
  =================================================================================================

    DELAY ELEMENT

  =================================================================================================
  -->
  <xsd:element name = "delay" type = "xsd:int" >
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          Defines a delay in milliseconds that can be used in a macro sequence.

      ]]></xsd:documentation>
    </xsd:annotation>
  </xsd:element>




  <!--
  =================================================================================================

    Section <config> tag

  =================================================================================================
  -->
  <xsd:element name="config">
    <xsd:annotation>
      <xsd:documentation><![CDATA[

          The <config> section is used to override default system configurations of controller


      ]]></xsd:documentation>
    </xsd:annotation>

    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref = "property" minOccurs = "0" maxOccurs = "unbounded" />
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

</xsd:schema>
